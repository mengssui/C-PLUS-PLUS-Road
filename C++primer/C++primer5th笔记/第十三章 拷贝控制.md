- [第十三章 拷贝控制](#第十三章-拷贝控制)
  - [13.1 **拷贝、赋值与销毁**](#131-拷贝赋值与销毁)
    - [13.1.1 **拷贝构造函数**](#1311-拷贝构造函数)
      - [合成拷贝构造函数](#合成拷贝构造函数)
      - [拷贝初始化](#拷贝初始化)
      - [参数和返回值](#参数和返回值)
      - [拷贝初始化的限制](#拷贝初始化的限制)
    - [13.1.2 **拷贝赋值运算符**](#1312-拷贝赋值运算符)
      - [重载赋值运算符](#重载赋值运算符)
      - [合成拷贝赋值运算符s](#合成拷贝赋值运算符s)
    - [13.1.3 **析构函数**](#1313-析构函数)
      - [**析构函数完成什么工作**](#析构函数完成什么工作)
      - [**合成析构函数**](#合成析构函数)
    - [13.1.4 **三/五法则**](#1314-三五法则)
    - [13.1.5 **使用=default**](#1315-使用default)
    - [13.1.6 **阻止拷贝**](#1316-阻止拷贝)
      - [**定义删除的函数**](#定义删除的函数)
      - [**private拷贝控制**](#private拷贝控制)
  - [13.2 **拷贝控制和资源管理**](#132-拷贝控制和资源管理)
    - [13.2.1 **行为像值的类**](#1321-行为像值的类)
      - [**类值拷贝赋值运算符**](#类值拷贝赋值运算符)
    - [13.2.2 **定义行为像指针的类**](#1322-定义行为像指针的类)
      - [**引用计数**](#引用计数)
  - [13.3 **交换操作**](#133-交换操作)
# 第十三章 拷贝控制
> 本章学习的目的：能够指定一个类对象在执行拷贝、移动、赋值和销毁时具体做什么
>           
>   一个类通过**特殊成员函数**来执行这些操作，称为**拷贝控制操作**, 共五个如下：
> - 拷贝构造函数
> - 拷贝赋值运算符
> - 移动构造函数
> - 移动赋值运算符
> - 析构函数 
>
><font color = red> 注意：这五个操作如果不定义，编译器会自动定义</font>

## 13.1 **拷贝、赋值与销毁**
### 13.1.1 **拷贝构造函数**
- 拷贝构造函数：构造函数第一个参数是自身类类型的引用，且任何额外值都有默认值
```cpp
className (const className&);
```
> 1. 第一个参数几乎总是const的引用
> 
> 2. 多种情况会被隐式引用，拷贝构造函数不应该是explicit的，不能禁止隐式转换
#### 合成拷贝构造函数
- 如果没有定义拷贝构造函数，编译器会为我们定义。
- 一般情况，合成的拷贝构造函数将其参数的成员逐个拷贝到正在创建的对象中，除了静态成员，成员类型决定了拷贝方式
#### 拷贝初始化
```cpp
//直接初始化，实际上是要求编译器使用普通的函数匹配来选择最匹配的构造函数，例如：
string dot(10,'s);
```
```cpp
//拷贝初始化，要求编译器将右侧对象拷贝到正在创建的对象中，有需要的话进行类型转换，通常由拷贝构造函数完成，也可以使用移动构造函数
//例如：
string s2 = dots;

此外拷贝初始化不仅在=时发生，也会发生在：
    实参传给非引用形参；
    函数返回非引用对象；
    花括号列表初始化数组或聚合类成员。
```
#### 参数和返回值
- 函数调用时候，非引用类型的参数进行拷贝初始化
- 函数返回类型时非引用类型
#### 拷贝初始化的限制
- 如果需要使用explicit的构造函数来进行类型转换，那么只能使用直接初始化，或是强制类型转换，或是直接构造临时变量
```cpp
//vector接收单一大小参数的构造函数时explicit的

vector<int> v1(1);//正确 直接初始化
vector<int> v2 = 10; //错误×
void f(vector<int>);//参数是拷贝初始化
f(10); //错误
f(vector<int>(10));//正确 构造临时变量
```
### 13.1.2 **拷贝赋值运算符**
#### 重载赋值运算符
- 重载运算符本质是函数，名字为operator加上要定义的运算符符号组成
- 赋值运算符就是名为operator=的函数
#### 合成拷贝赋值运算符s
```cpp
Sales_data trans, accum;
trans = accum; //使用Sales_data的拷贝赋值运算符
```
- 如果没有自定义拷贝赋值运算符，则编译器会生成合成拷贝赋值运算符 
```cpp
//这个定义的拷贝赋值函数等价于合成拷贝赋值运算符
Sales_data& Sales_data::operator=(const Sales_data &rhs) {
    bookNo = rhs.bookNo;
    units = rhs.units;
    return *this;
}
```
### 13.1.3 **析构函数**
- 析构函数释放对象使用的资源，并且销毁对象的非static数据成员
- 析构函数是类的一个成员函数，名字由波浪号接类名构成。他没有返回值，也不接受参数：

``` cpp
~ClassName(); 
//析构函数唯一
```
#### **析构函数完成什么工作**
- 析构函数与构造函数相反，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。
- 销毁类类型成员需要执行自己的析构函数；内置类型没有析构函数，因此销毁内置类型成员什么也不需要做
#### **合成析构函数**

- 当类未定义自己的析构函数时，编译器会为它定义一个合成析构函数
- 析构函数体自身并不直接销毁成员是，成员是在析构函数体之后隐含的析构阶段被销毁的。
### 13.1.4 **三/五法则**
* 这些拷贝控制操作通常我们认为是一个整体，最好同时定义或是使用默认
* 需要析构函数的类也需要拷贝和赋值操作
* 需要拷贝操作的类也需要赋值操作，反之亦然
### 13.1.5 **使用=default**
* 显示要求编译器生成合成版本的，使用=default
*- 合成函数隐式声明为内联的，否则要在类外定义使用=default
### 13.1.6 **阻止拷贝**
* 有些类希望阻止拷贝和赋值，例如iostream，避免多个对象写入或读取相同的IO缓冲
#### **定义删除的函数**
* 可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**，删除的函数是虽然声明了，但是不能以任何方式使用，函数参数列表后加上=delete，必须在函数第一次声明的时候
* 可以对任何函数指定为=delete
* 析构函数不能是删除的成员
* 合成的拷贝控制成员可能是删除的
* 如果类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的
#### **private拷贝控制**

* 类也可以通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝，但不推荐

---
---
## 13.2 **拷贝控制和资源管理**
* 两种，一种类的行为像值，另一种行为像指针。
* 类像值，以为两个拷贝的副本和原来的对象完全独立，改变一个不影响另一个
* 类像指针，共享状态，副本和原对象使用相同的底层数据，改变一个也会改变另一个
### 13.2.1 **行为像值的类**
* 每个对象拥有一份自己的拷贝
#### **类值拷贝赋值运算符**
* 赋值运算符通常组合了析构函数和构造函数的操作
* 一般应该：先将右侧运算对象拷贝到局部临时变量，销毁左侧对象享有成员，将局部临时变量拷贝到左侧运算对象
* 赋值运算符要能够处理赋值自身的情况
```cpp
ClassName& ClassName::operator=(const ClassName& rhs) {
  auto newp = new string(*rhs.ps);  //将右侧的保存到临时局部变量
  delete ps;  //销毁左侧对象
  ps = newp; //将局部赋值给左侧
  i = rhs.i; //内置类型（不包含指针）本身就是值
  return *this;
}
```
### 13.2.2 **定义行为像指针的类**
- 我们需要定义拷贝构造函数和拷贝赋值运算符，来拷贝指针本身而不是它指向的值
- shared_ptr是最好的方法，让类行为类似指针，用它管理类中资源
#### **引用计数**
- 记录记录有多少个对象共享
- 将计数器保存在动态内存中，当创建对象我们分配新的计数器，当拷贝或赋值，我们拷贝指向计数器的指针，这样，副本和原对象都会指向相同的计数器。

```cpp
ClassName& ClassName::operator=(const ClassName& rhs) {
  ++*rhs.use; //递增右侧运算对象的引用计数
  if (--*use == 0) {  //递减左侧
    delete ps;    //递减至0释放空间
    delete use;
  }
  ps = rhs.ps; 
  i = rhs.i; //内置类型（不包含指针）本身就是值
  use = rhs.use;
  return *this;
}
```
---

---

## 13.3 **交换操作**
- 管理资源的类通常还定义一个swap函数，交换两个元素
- 如果不定义，则使用标准库定义的swap
- 为了交换要进行一次拷贝，两次赋值；但是理论上内存分配是不必要的，希望swap交换指针
- 定义swap的类通常用swap定义它们的赋值运算符，使用拷贝并交换技术，是异常安全的，能够正确处理自赋值

----
----

