- [第十三章 拷贝控制](#第十三章-拷贝控制)
  - [13.1 **拷贝、赋值与销毁**](#131-拷贝赋值与销毁)
    - [13.1.1 **拷贝构造函数**](#1311-拷贝构造函数)
      - [**合成拷贝构造函数**](#合成拷贝构造函数)
      - [**拷贝初始化**](#拷贝初始化)
      - [**参数和返回值**](#参数和返回值)
      - [**拷贝初始化的限制**](#拷贝初始化的限制)
    - [13.1.2 **拷贝赋值运算符**](#1312-拷贝赋值运算符)
      - [**重载赋值运算符**](#重载赋值运算符)
      - [**合成拷贝赋值运算符**](#合成拷贝赋值运算符)
    - [13.1.3 **析构函数**](#1313-析构函数)
      - [**析构函数完成什么工作**](#析构函数完成什么工作)
      - [**合成析构函数**](#合成析构函数)
    - [13.1.4 **三/五法则**](#1314-三五法则)
    - [13.1.5 **使用=default**](#1315-使用default)
    - [13.1.6 **阻止拷贝**](#1316-阻止拷贝)
      - [**定义删除的函数**](#定义删除的函数)
      - [**private拷贝控制**](#private拷贝控制)
  - [13.2 **拷贝控制和资源管理**](#132-拷贝控制和资源管理)
    - [13.2.1 **行为像值的类**](#1321-行为像值的类)
      - [**类值拷贝赋值运算符**](#类值拷贝赋值运算符)
    - [13.2.2 **定义行为像指针的类**](#1322-定义行为像指针的类)
      - [**引用计数**](#引用计数)
  - [13.3 **交换操作**](#133-交换操作)
  - [13.4 **拷贝控制示例**](#134-拷贝控制示例)
  - [13.5 **动态内存管理类**](#135-动态内存管理类)
      - [**StrVec类的设计**](#strvec类的设计)
      - [**StrVec类定义**](#strvec类定义)
  - [13.6 **对象移动**](#136-对象移动)
    - [13.6.1 **右值引用**](#1361-右值引用)
      - [**左值持久；右值短暂**](#左值持久右值短暂)
      - [**变量是左值**](#变量是左值)
      - [**标准库move函数**](#标准库move函数)
    - [13.6.2 **移动构造函数和移动赋值运算符**](#1362-移动构造函数和移动赋值运算符)
      - [**移动赋值运算符**](#移动赋值运算符)
      - [**移后源对象必须可析构**](#移后源对象必须可析构)
      - [**合成的移动操作**](#合成的移动操作)
      - [**移动右值，拷贝左值**](#移动右值拷贝左值)
      - [**拷贝并交换赋值运算符和移动操作**](#拷贝并交换赋值运算符和移动操作)
      - [**移动迭代器**](#移动迭代器)
    - [13.6.3 **右值引用和成员函数**](#1363-右值引用和成员函数)
      - [**右值和左值引用成员函数**](#右值和左值引用成员函数)
      - [**重载和引用函数**](#重载和引用函数)
# 第十三章 拷贝控制
> 本章学习的目的：能够指定一个类对象在执行拷贝、移动、赋值和销毁时具体做什么
>           
>   一个类通过**特殊成员函数**来执行这些操作，称为**拷贝控制操作**, 共五个如下：
> - 拷贝构造函数
> - 拷贝赋值运算符
> - 移动构造函数
> - 移动赋值运算符
> - 析构函数 
>
><font color = red> 注意：这五个操作如果不定义，编译器会自动定义</font>

## 13.1 拷贝、赋值与销毁
### 13.1.1 **拷贝构造函数**
- 拷贝构造函数：构造函数第一个参数是自身类类型的引用，且任何额外值都有默认值
```cpp
className (const className&); 
```
> 1. 第一个参数几乎总是const的引用
> 
> 2. 多种情况会被隐式引用，拷贝构造函数不应该是explicit的，不能禁止隐式转换
#### **合成拷贝构造函数**
- 如果没有定义拷贝构造函数，编译器会为我们定义。
- 一般情况，合成的拷贝构造函数将其参数的成员逐个拷贝到正在创建的对象中，除了静态成员，成员类型决定了拷贝方式
#### **拷贝初始化**
```cpp
//直接初始化，实际上是要求编译器使用普通的函数匹配来选择最匹配的构造函数，例如：
string dot(10,'s);
```
```cpp
//拷贝初始化，要求编译器将右侧对象拷贝到正在创建的对象中，有需要的话进行类型转换，通常由拷贝构造函数完成，也可以使用移动构造函数
//例如：
string s2 = dots;

此外拷贝初始化不仅在=时发生，也会发生在：
    实参传给非引用形参；
    函数返回非引用对象；
    花括号列表初始化数组或聚合类成员。
```
#### **参数和返回值**
- 函数调用时候，非引用类型的参数进行拷贝初始化
- 函数返回类型时非引用类型
#### **拷贝初始化的限制**
- 如果需要使用explicit的构造函数来进行类型转换，那么只能使用直接初始化，或是强制类型转换，或是直接构造临时变量
```cpp
//vector接收单一大小参数的构造函数时explicit的

vector<int> v1(1);//正确 直接初始化
vector<int> v2 = 10; //错误×
void f(vector<int>);//参数是拷贝初始化
f(10); //错误
f(vector<int>(10));//正确 构造临时变量
```
### 13.1.2 **拷贝赋值运算符**
#### **重载赋值运算符**
- 重载运算符本质是函数，名字为operator加上要定义的运算符符号组成
- 赋值运算符就是名为operator=的函数
#### **合成拷贝赋值运算符**
```cpp
Sales_data trans, accum;
trans = accum; //使用Sales_data的拷贝赋值运算符
```
- 如果没有自定义拷贝赋值运算符，则编译器会生成合成拷贝赋值运算符 
```cpp
//这个定义的拷贝赋值函数等价于合成拷贝赋值运算符
Sales_data& Sales_data::operator=(const Sales_data &rhs) {
    bookNo = rhs.bookNo;
    units = rhs.units;
    return *this;
}
```
### 13.1.3 **析构函数**
- 析构函数释放对象使用的资源，并且销毁对象的非static数据成员
- 析构函数是类的一个成员函数，名字由波浪号接类名构成。他没有返回值，也不接受参数：

``` cpp
~ClassName(); 
//析构函数唯一
```
#### **析构函数完成什么工作**
- 析构函数与构造函数相反，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。
- 销毁类类型成员需要执行自己的析构函数；内置类型没有析构函数，因此销毁内置类型成员什么也不需要做
#### **合成析构函数**

- 当类未定义自己的析构函数时，编译器会为它定义一个合成析构函数
- 析构函数体自身并不直接销毁成员是，成员是在析构函数体之后隐含的析构阶段被销毁的。
### 13.1.4 **三/五法则**
* 这些拷贝控制操作通常我们认为是一个整体，最好同时定义或是使用默认
* 需要析构函数的类也需要拷贝和赋值操作
* 需要拷贝操作的类也需要赋值操作，反之亦然
* 更新：通常五个拷贝控制应该作为一个整体，同时定义，同时不定义
### 13.1.5 **使用=default**
* 显示要求编译器生成合成版本的，使用=default
*- 合成函数隐式声明为内联的，否则要在类外定义使用=default
### 13.1.6 **阻止拷贝**
* 有些类希望阻止拷贝和赋值，例如iostream，避免多个对象写入或读取相同的IO缓冲
#### **定义删除的函数**
* 可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝，删除的函数是虽然声明了，但是不能以任何方式使用，函数参数列表后加上=delete，必须在函数第一次声明的时候
* 可以对任何函数指定为=delete
* 析构函数不能是删除的成员
* 合成的拷贝控制成员可能是删除的
* 如果类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的
#### **private拷贝控制**

* 类也可以通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝，但不推荐

---
---
## 13.2 **拷贝控制和资源管理**
* 两种，一种类的行为像值，另一种行为像指针。
* 类像值，以为两个拷贝的副本和原来的对象完全独立，改变一个不影响另一个
* 类像指针，共享状态，副本和原对象使用相同的底层数据，改变一个也会改变另一个
### 13.2.1 **行为像值的类**
* 每个对象拥有一份自己的拷贝
#### **类值拷贝赋值运算符**
* 赋值运算符通常组合了析构函数和构造函数的操作
* 一般应该：先将右侧运算对象拷贝到局部临时变量，销毁左侧对象享有成员，将局部临时变量拷贝到左侧运算对象
* 赋值运算符要能够处理赋值自身的情况
```cpp
ClassName& ClassName::operator=(const ClassName& rhs) {
  auto newp = new string(*rhs.ps);  //将右侧的保存到临时局部变量
  delete ps;  //销毁左侧对象
  ps = newp; //将局部赋值给左侧
  i = rhs.i; //内置类型（不包含指针）本身就是值
  return *this;
}
```
### 13.2.2 **定义行为像指针的类**
- 我们需要定义拷贝构造函数和拷贝赋值运算符，来拷贝指针本身而不是它指向的值
- shared_ptr是最好的方法，让类行为类似指针，用它管理类中资源
#### **引用计数**
- 记录记录有多少个对象共享
- 将计数器保存在动态内存中，当创建对象我们分配新的计数器，当拷贝或赋值，我们拷贝指向计数器的指针，这样，副本和原对象都会指向相同的计数器。

```cpp
ClassName& ClassName::operator=(const ClassName& rhs) {
  ++*rhs.use; //递增右侧运算对象的引用计数
  if (--*use == 0) {  //递减左侧
    delete ps;    //递减至0释放空间
    delete use;
  }
  ps = rhs.ps; 
  i = rhs.i; //内置类型（不包含指针）本身就是值
  use = rhs.use;
  return *this;
}
```
---

---

## 13.3 **交换操作**
- 管理资源的类通常还定义一个swap函数，交换两个元素
- 如果不定义，则使用标准库定义的swap
- 为了交换要进行一次拷贝，两次赋值；但是理论上内存分配是不必要的，希望swap交换指针
- 定义swap的类通常用swap定义它们的赋值运算符，使用拷贝并交换技术，是异常安全的，能够正确处理自赋值

## 13.4 **拷贝控制示例**
[Message](../message.hpp)

[folders](../folders.hpp)

----
----
## 13.5 **动态内存管理类**
- 某些类需要在运行时分配可变大小的内存空间，可以通过使用标准库容器来保存它们的数据，但这个策略不是普适的，某些类需要自己进行内存分配，必须要定义自己的拷贝控制成员

简单实现vector的简化版本，不使用模板，只使用string，命名为StrVec
#### **StrVec类的设计**
为了获得可以接受的性能，vector预先分配一定的空间，每个添加元素的成员函数都会先检查是否可以容纳，如果有则继续，否则就会重新分配空间，将已有元素移动到新空间中，释放旧的空间，添加新的元素。
> StrVec需要的功能：
> 1. elements 指向分配的内存中的首元素
> 2. first_free 指向最后一个实际元素之后的位置
> 3. cap 指向分配的内存末尾之后的位置
> 4. 静态成员alloc，类型是allocator<string>
> 5. alloc_n_copy 分配内存，并拷贝一个给定范围内的元素
> 6. free 会销毁构造的元素并释放内存
> 7. chk_n_alloc保证StrVec中至少有容纳一个新元素的空间
> 8. reallocate在内存用完时分配新内存

#### **StrVec类定义**
[StrVec](../strvec.hpp)

---

---

## 13.6 **对象移动**
- 新标准最主要的特性是可以移动而非拷贝对象
### 13.6.1 **右值引用**
- 为了支持移动操作，引入新的类型，右值引用——**必须绑定到右值的引用**，使用符号&&而不是&，与平时的引用（左值引用）有着相反的特性
#### **左值持久；右值短暂**
- 右值引用只能绑定到临时对象，所引用的对象将要被销毁；该对象没有其他用户。
#### **变量是左值**
- 变量是左值，不能将右值引用绑定到一个右值引用类型的变量上
```cpp
int &&rr1 = 43;
int &&rr2 = rr1; //错误❌，rr1是变量，是左值
```
#### **标准库move函数**
- 头文件在utility中
- 不可以将右值引用直接绑定到左值上，但是可以显示地将左值转换为对应的右值类型，我们还可以通过调用move来获得绑定到左值上的右值引用。
```cpp
//使用move意味着希望像右值一样处理一个左值，
//承诺我们不再使用rr1，仅作赋值或销毁
int &&rr3 = std::move(rr1); 
```
- 使用move不提供using声明，必须使用std::move
- 可以**销毁**或**赋值**一个移后源对象，但**不可使用移后源对象的值** 

### 13.6.2 **移动构造函数和移动赋值运算符**
- 为了让自己的类型支持移动操作，需要定义移动构造函数和移动赋值运算符
- 类似拷贝构造函数，移动构造函数的第一个参数是该类型的右值引用，其余额外参数必须有默认实参。
- 移动构造函数完成资源移动，还要保证移后源对象处于这样一个状态——销毁它是无害的
```cpp
StrVec::StrVec(StrVec &&S) noexcept 
    : elements(s.elements), first_free(s.first_free),
    cap(s.cap) {
      s.elements = s.first_free = s.cap = nullptr;
    }
//避免编译器做为了处理抛出异常的额外操作，我们使用noexpect通知指明不抛出异常
```
- 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexpect
- 除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存过程中，必须使用拷贝构造函数而不是移动构造函数；如果希望使用移动构造函数，必须标记noexpect
#### **移动赋值运算符**
- 如果不抛出异常，则需要标记noexpect，必须正确处理自赋值
#### **移后源对象必须可析构**
- 确保移后源对象进入一个可析构的状态
- 保证对象有效，可安全赋予新值或使用，不应该依赖移后源对象的数据
#### **合成的移动操作**
- 只有一个类没有定义任何自己版本的拷贝控制成员，且它所有数据成员都能移动构造或移动赋值，编译器才会为它合成移动构造函数或移动赋值运算符
- 移动操作不会隐式定义为删除的函数，但是如果显示要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器将移动操作定义为删除的函数。
- 类的成员未定义移动构造函数或是移动构造函数删除的/不可见的，则合成移动操作被定义为删除的函数
- 一个类如果定义了移动构造函数或移动赋值运算符，则该类的合成拷贝函数和合成拷贝赋值运算符被定义为删除的，除非自己定义。
#### **移动右值，拷贝左值**
- 如果一个类既有移动构造函数，也有拷贝构造函数，编译器则使用默认的函数匹配。赋值操作类似。
- 如果没有移动构造函数，右值也被拷贝
#### **拷贝并交换赋值运算符和移动操作**
- 如果定义移动构造函数，则赋值运算符既是移动赋值运算符，又是拷贝赋值运算符
- 运算符非引用参数表明其进行拷贝构造函数或是移动构造函数，左值被拷贝，右值被移动。一个顶俩。
#### **移动迭代器**
- 标准库的make_move_iterator,移动迭代器的解引用运算符生成一个右值引用

由于一个移后源对象具有不确定的状态，因此对其调用std::move是危险的，当我们使用移动操作必须确定移后源对象没有其他用户。
### 13.6.3 **右值引用和成员函数**
一般允许移动的成员函数通常使用一个版本接收*指向const的左值引用*，第二个版本接收*指向非const的右值引用*。
```cpp
void push_back(const T&);
void push_back(T&&);
```
#### **右值和左值引用成员函数**
- 调用对象上的成员函数，不管其是左值还是右值
- 为了向后兼容，新版本允许向右值赋值，但是为了阻止这种用法，可以强制左侧运算对象是一个左值，使用在参数列表后放置引用限定符,可以是&或&&，一个表示可指向左值，两个表示可指向右值
```cpp
//只可向可修改的左值赋值
ClassName &operator=(const ClassName&) &;  
```
- 若函数同时用const和&，则&必须在const限定符之后
#### **重载和引用函数**
- 引用限定符也可以区分重载版本，如果定义两个及以上同名同参数列表的成员函数，引用限定符需要同时加或同时不加
