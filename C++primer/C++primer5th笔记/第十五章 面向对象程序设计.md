- [**第十五章 面向对象程序设计**](#第十五章-面向对象程序设计)
  - [15.1 **OOP概述**](#151-oop概述)
      - [继承](#继承)
      - [动态绑定](#动态绑定)
  - [15.2 **定义基类和派生类**](#152-定义基类和派生类)
    - [15.2.1 **定义基类**](#1521-定义基类)
      - [成员函数与继承](#成员函数与继承)
      - [访问控制与继承](#访问控制与继承)
    - [15.2.2 **定义派生类**](#1522-定义派生类)
      - [派生类中的虚函数](#派生类中的虚函数)
      - [派生类对象及派生类对象向基类的类型转换](#派生类对象及派生类对象向基类的类型转换)
      - [派生类构造函数](#派生类构造函数)
      - [派生类使用基类的成员](#派生类使用基类的成员)
      - [继承与静态成员](#继承与静态成员)
      - [派生类的声明](#派生类的声明)
      - [被用作基类的类](#被用作基类的类)
      - [阻止继承发生](#阻止继承发生)
    - [15.2.3 **类型转换与继承**](#1523-类型转换与继承)
      - [静态类型与动态类型](#静态类型与动态类型)
      - [不存在基类向派生类的隐式转换](#不存在基类向派生类的隐式转换)
      - [对象之间不存在类型转换](#对象之间不存在类型转换)
  - [15.3 **虚函数**](#153-虚函数)
      - [对虚函数的调用可能在运行时才被解析](#对虚函数的调用可能在运行时才被解析)
      - [派生类中的虚函数](#派生类中的虚函数-1)
      - [final和override说明符](#final和override说明符)
      - [虚函数与默认实参](#虚函数与默认实参)
      - [回避虚函数的机制](#回避虚函数的机制)
  - [15.4 **抽象基类**](#154-抽象基类)
      - [纯虚函数](#纯虚函数)
      - [含有纯虚函数的类是抽象基类](#含有纯虚函数的类是抽象基类)
      - [派生类构造函数只初始化它的直接基类](#派生类构造函数只初始化它的直接基类)
  - [15.5 **访问控制与继承**](#155-访问控制与继承)
      - [受保护的成员](#受保护的成员)
      - [公有,私有和受保护继承](#公有私有和受保护继承)
      - [派生类向基类转换的可行性](#派生类向基类转换的可行性)
      - [友元与继承](#友元与继承)
      - [改变个别成员的可访问性](#改变个别成员的可访问性)
      - [默认的继承保护级别](#默认的继承保护级别)
  - [15.6 **继承中的类作用域**](#156-继承中的类作用域)
      - [在编译时进行名字查找](#在编译时进行名字查找)
      - [名字冲突与继承](#名字冲突与继承)
      - [名字查找优先于类型检查](#名字查找优先于类型检查)
      - [覆盖重载函数](#覆盖重载函数)
  - [15.7 **构造函数与拷贝控制**](#157-构造函数与拷贝控制)
    - [15.7.1 **虚析构函数**](#1571-虚析构函数)
    - [15.7.2 **合成拷贝控制与继承**](#1572-合成拷贝控制与继承)
      - [移动操作与继承](#移动操作与继承)
    - [15.7.3 **派生类的拷贝控制成员**](#1573-派生类的拷贝控制成员)
      - [定义派生类的拷贝或移动构造函数](#定义派生类的拷贝或移动构造函数)
      - [派生类赋值运算符](#派生类赋值运算符)
      - [派生类析构函数](#派生类析构函数)
      - [在构造函数和析构函数中调用虚函数](#在构造函数和析构函数中调用虚函数)
    - [15.7.4 **继承的构造函数**](#1574-继承的构造函数)
  - [15.8 **容器与继承**](#158-容器与继承)
      - [在容器中放置（智能）指针而非对象](#在容器中放置智能指针而非对象)

---

---



# **第十五章 面向对象程序设计**
## 15.1 **OOP概述**
面向对象程序设计的核心思想是 **数据抽象  继承  动态绑定**
- 数据抽象:类的接口与实现分离
- 继承:定义相似类型,对相似关系建模
- 动态绑定:一定程度忽略相似类型的区别,统一使用其对象

#### 继承
继承使联系在一起的类有层次关系, 层次关系的根部为**基类**, 其余直接或间接从基类继承为**派生类**,
- 基类负责定义层次关系中所有类的共同的成员 
- 派生类定义各自特有成员
- 对于一些函数,基类希望有派生类各自定义合适的版本,通常将这些函数声明为**虚函数**
- 派生类通过类派生列表来指明从哪些基类继承而来
  - 格式为: 冒号之后加上以逗号分隔的基类列表,其中每个基类前面可以加访问说明符
- 派生类必须在其内部对所有重新定义的虚函数进行声明,可以在函数之前加上virtual关键字, 也可以在函数形参列表之后加上override关键字说明
#### 动态绑定
当我们使用基类的引用或指针调用一个虚函数时,将发生动态绑定, 也称为运行时绑定

---

---

## 15.2 **定义基类和派生类**
### 15.2.1 **定义基类**
基类通常应该都定义一个虚析构函数,即使其不执行任何操作
```cpp
//基类
class Quote {
 public:
  Quote() = default; //定义默认构造函数,因为既需要默认的,也需要自定义的
  Quote(const string& book, double sales_price)
    : book_no_(book), price_(sales_price) { }
  string isbn() const { return book_no_; }
  virtual double net_price(size_t num) const { return num * price_; }
  virtual ~Quote () = default; //对析构函数动态绑定
 private:
  string book_no_;
 protected:
  double price_ = 0.0;
};
```
#### 成员函数与继承
派生类可以继承基类成员,对于与类型相关的操作(如virtual)派生类必须对其重新定义, 派生类需要对这些操作提供自己的新定义来覆盖继承而来的旧定义
> C++必须区分开两种成员函数:
> 
> 1. 希望派生类进行覆盖的函数   (将此种定义为虚函数virtual)
> 2. 希望派生类直接继承不要改变的函数
>
>用指针或引用调用虚函数使得调用动态绑定,任何构造函数之外的非静态函数可以是虚函数,根据指针或引用的对象的不同,可能的调用基类或是派生类的版本,关键字virtual只能出现在类的内部声明语句之前,不可用于外部定义
#### 访问控制与继承
派生类可以继承定义在基类中的成员,但是派生类的成员函数不一定有权访问基类继承的成员, 派生类能够访问公有成员,不能访问私有成员,受保护的(protected)成员可被派生类访问,而不能被其他用户访问

### 15.2.2 **定义派生类**
派生类通过类派生列表来指明从哪些基类继承而来, 格式为: 冒号之后加上以逗号分隔的基类列表,其中每个基类前面可以加访问说明符
```cpp
class BulkQuote : public Quote {
 public:
  BulkQuote() = default;
  BulkQuote(const string&, double, size_t, double);
  //覆盖基类
  double net_price(size_t) const override;
 private:
  size_t min_qty_ = 0;
  double discount = 0.0;
};
```
**访问说明符控制派生类从基类继承而来的成员是否对派生类的用户可见**,继承自一个类称为单继承

#### 派生类中的虚函数
派生类通常覆盖其继承的虚函数,如果没有覆盖,则该虚函数的行为类似于普通成员,派生类直接继承基类中的版本
- 用关键字override显式覆盖继承的虚函数
#### 派生类对象及派生类对象向基类的类型转换
- 派生类含有多个组成部分
  - 含有派生类自己定义的（非静态）成员的子对象，
  - 该派生类继承的基类对应的子对象，若有多个基类，则子对象有多个
- 因为派生类对象中含有基类对应的部分，因此能把派生类对象当作基类对象来使用

```cpp
Quote item;
BulkQuote bulk;
Quote* p = &item;
p = &bulk;   //指向bulk中的Quote部分
Quote& r = bulk;  //绑定到Quote部分
```
这种转换称为:派生类到基类的类型转换,隐式执行

#### 派生类构造函数
派生类不能直接初始化基类继承而来的成员,必须通过基类的构造函数来初始化基类部分,每个类控制自己的成员初始化过程.
除非特别指出,否则基类部分执行默认初始化.
- 首先初始化基类部分,然后按照声明的顺序依次初始化派生类成员
#### 派生类使用基类的成员
派生类可以访问基类的公有成员和受保护成员

派生类作用域嵌套在基类的作用域内部

#### 继承与静态成员
基类中的静态成员在整个继承体系中只存在该成员唯一定义.
- 静态成员遵循通用的访问控制规则,如果private的,则派生类不能访问;如果是可访问的,我们可通过基类和派生类使用它.
#### 派生类的声明
派生类声明中包含类名,不包含派生列表,因为声明的目的是让程序知道名字的存在和类型,派生列表以及与定义有关的其他细节必须与类的主体一起出现
#### 被用作基类的类
如果想用某个类作为基类,则该必须已经定义而并非仅仅声明,因为派生类包含从基类继承而来的成员,为了使用这些成员,派生类需要知道他们是什么.   此外, 一个类的不能派生其本身.
- 一个类可以是基类,也可以是派生类,  直接基类和间接基类,最终的派生类包含它的直接基类的子对象和间接基类的子对象.
#### 阻止继承发生
定义一个类,不希望继承它,在类名后加**关键字 final**

### 15.2.3 **类型转换与继承**
- 我们可以将基类的指针或引用绑定到派生类的对象上
- 当使用基类的引用或指针时，我们并不知道该引用或指针所绑定的对象的真是类型，可能是基类，可能是派生类
#### 静态类型与动态类型
- 当我们使用继承关系的类型时候，必须将一个变量或其他表达式的静态类型与其表达对象的动态类型区分开
- 如果表达式既不是引用，也不是指针，则它的动态类型永远与静态类型保持一致
#### 不存在基类向派生类的隐式转换
派生类可以向基类转换是因为每个派生类对象都包含一个基类部分，基类的引用或指针可以绑定到这一部分
- 当然，可以是用static_cast强制类型转换来覆盖掉编译器检查工作

#### 对象之间不存在类型转换
派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换
- 当我们用一个派生类为一个基类对象初始化或赋值时，只有派生类对象中的基类部分会被拷贝，移动或是赋值，他的派生类部分将被**切掉**

> 关键三点：
> 
> 1. 从派生类向基类的类型转换只对指针或引用类型有效
> 2. 基类向派生类不存在隐式转换
> 3. 派生类向基类的转换可能由于访问受限而不可行

---

---

## 15.3 虚函数
C++语言中，当我们使用**基类的引用或是指针**调用一个**虚成员函数时会执行动态绑定**，因为直到运行时才知道调用了哪个版本的虚函数，所有虚函数必须都有定义，我们必须为每一个虚函数提供定义，无论是否用到。
#### 对虚函数的调用可能在运行时才被解析
- 动态绑定只有当我们通过引用或指针调用虚函数时才会发生，编译器直到运行时才确定应该调用哪个版本的函数
> OOP核心思想是多态性,把具有继承关系的多个类型称为多态类型
#### 派生类中的虚函数
- 某个函数一旦被声明为虚函数,则在所有派生类中都是虚函数
- 派生类的函数如果覆盖了某个继承而来的虚函数,则它的形参类型必须与被他覆盖的基类函数完全一致
-  同样,返回类型也要一致. 不过有例外,如果虚函数返回类型时类本身的指针或引用,则返回类型可以不一致, 但是派生类到基类的转换是可以访问的.
#### final和override说明符
由于如果不小心定义了与基类相同名字但是不同形参的列表时候,编译器会认为是两个独立的函数,误解了编程意图. 也会会报错.
- 为了解决这种问题,加入override,来说明派生类中的虚函数

final指定某个函数之后不能覆盖,如果覆盖引发错误

#### 虚函数与默认实参
函数调用使用默认实参,实参值由调用的静态类型决定,意味着如果我们通过基类的引用或指针调用函数,默认的实参会使用基类中的,即使实际运行的是派生类的函数版本.
> 如果虚函数使用默认实参,则基类和派生类中定义的默认实参最好一致.

#### 回避虚函数的机制
某些情况我们希望虚函数的调用不要进行动态绑定而是强迫执行虚函数的某个版本,使用作用域运算符实现这个目的

什么情况下可能用到这个呢? 通常是派生类的虚函数调用它的基类的虚函数版本,基类版本完成所有类型都要做的任务,派生类版本执行一些派生类本身密切相关的操作

## 15.4 **抽象基类**
#### 纯虚函数
纯虚函数无需定义，通过=0 加到声明语句分号之前来表示.
表示当前的这个函数没有实际意义
可以为纯虚函数定义,必须在类外部

#### 含有纯虚函数的类是抽象基类
- 含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类,抽象基类负责定义接口,而后续其他类可以覆盖该接口
- 我们不能直接创建一个抽象基类的对象,因为无法定义其中的纯虚函数
- 我们可以定义由抽象基类派生类的对象,前提是派生类覆盖了抽象基类中的纯虚函数
> 抽象基类的派生类必须要覆盖纯虚函数,否则派生类仍将是抽象基类.

#### 派生类构造函数只初始化它的直接基类

> 重构负责重新设计类的体系以便将操作和数据从一个类移动到另一个类中.

---

---

## 15.5 访问控制与继承
#### 受保护的成员
使用protected关键字来声明那些希望与派生类分享,但是不想被其他公共访问使用的成员
- 类似私有成员,用户不可访问受保护成员
- 类似公有成员,派生类的成员和友元可以访问受保护成员
- 派生类的成员或友元只能通过派生类对象来访问基类受保护成员,对于基类对象中的受保护成员没有访问特权

#### 公有,私有和受保护继承
一个类对继承而来的成员访问权限受到两个因素影响: 基类中成员访问说明符;  派生类列表中的访问说明符
- 派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员无影响, 对基类成员的访问权限仅与基类中的访问说明符有关
- 派生访问说明符控制派生类用户对于基类成员的访问权限
  

#### 派生类向基类转换的可行性
对于代码中某个节点,如果可以访问基类的公有成员,则派生类向基类的类型转换也是可行的,反之不行.
#### 友元与继承
友元关系不能传递, 友元关系不能继承
#### 改变个别成员的可访问性
使用using声明改变直接或间接基类中的任何可访问成员(非私有成员)标记出来,using声明语句中的名字的访问权限由该using声明之前的访问说明符来决定
#### 默认的继承保护级别
struct和class关键字定义的类具有不同的默认访问说明符,默认派生运算符也由定义派生类所用的关键字来决定
- 使用class关键字定义的派生类是私有继承的
- 使用struct关键字定义的派生类是共哟继承的

> struct和class唯一的区别是默认成员访问说明符合默认派生访问说明符

---

---

## 15.6 继承中的类作用域
每个类定义自己的作用域，作用域内定义成员，当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。
#### 在编译时进行名字查找
一个对象、引用或指针的静态类型决定了该对象的哪些成员可见，即使动态类型和静态类型不一致。
#### 名字冲突与继承
- 派生类的成员将隐藏其基类的成员
- 通过作用域运算符来使用隐藏的成员

#### 名字查找优先于类型检查
声明在内层作用域的函数并不会重载声明在外层作用域的函数，如果派生类中的函数与基类的某个成员同名，则派生类将在其作用域内隐藏该基类成员，即使形参列表不一致。
#### 覆盖重载函数
基类中可能有多个重载函数，派生类希望覆盖重载函数中的一部分，解决方法是：使用using声明语句指定一个名字而不指定形参列表，一条基类成员函数的using声明语句就可以把该函数所有重载实例添加到派生类作用域。 之后派生类仅需对特定参数的函数定义，无需为其他继承而来的函数定义。

---

---

## 15.7 构造函数与拷贝控制
### 15.7.1 **虚析构函数**
基类通常定义虚析构函数，delete一个动态分配对象的指针，可能出现动态类型和静态类型不一致的情况，因此需要把析构函数定义为虚函数来确保执行正确的析构函数版本。

如：基类的指针指向派生类，调用析构函数执行的时派生类的析构函数

- 只要基类时虚析构函数，则派生类的都是虚析构函数
- 虚析构函数将阻止合成移动操作

### 15.7.2 **合成拷贝控制与继承**
一般来说基类中不可访问的或是删除的合成拷贝控制，则派生类也不能进行相应的操作，因为基类没有对应操作。

如果基类没有默认、拷贝或移动构造函数，通常派生类也不会定义

#### 移动操作与继承
基类缺少移动操作会阻止派生类拥有自己的合成移动操作，如果需要执行移动操作，首先要在基类中进行显示定义，一旦基类定义了自己的移动操作，那么它必须同时显式地定义拷贝操作。
### 15.7.3 **派生类的拷贝控制成员**
派生类定义的拷贝或移动操作，该操作也负责基类部分的成员
#### 定义派生类的拷贝或移动构造函数
- 基类默认构造函数初始化派生类对象的基类部分，如果希望拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中显示地使用基类的拷贝或移动构造函数
```cpp
    D(const D& d) : Base(d)
    D(D&& d) Base(std::move(d))
```
#### 派生类赋值运算符
必须显式地为其基类部分赋值,在派生类的赋值运算符的内部,必须先使用基类的赋值运算符为基类部分赋值
#### 派生类析构函数
派生类析构函数只负责销毁由派生类自己分配的资源

对象的销毁顺序正好与其创建的顺序相反:派生类析构函数首先执行,然后是基类的析构函数,以此类推,沿着继承体系的反方向直至最后

#### 在构造函数和析构函数中调用虚函数
虚函数要执行动态绑定,而执行构造函数和析构函数,可能想动态绑定的虚函数还没有定义或是已经销毁,因此程序会崩溃的

所以如果构造函数或析构函数调用了某个虚函数,则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本

### 15.7.4 **继承的构造函数**
继承构造函数并非常规方式

一个类只初始化直接基类,一个类也只继承其直接基类的构造函数。

类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义，则编译器会合成他们

派生类使用using声明基类名来继承构造函数
`using Base::Base;`

构造函数的using不会改变访问级别，这与using普通成员不同

基类构造函数的默认实参不会被继承，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参

继承的默认构造函数不会被作为用户定义的构造函数，如果一个类只含有继承的构造函数，则它也会拥有一个合成的默认构造函数。

---

---

## 15.8 **容器与继承**
当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式，因为不允许在容器中保存不同类型的元素

当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。
#### 在容器中放置（智能）指针而非对象
当我们使用容器存放继承体系中的对象时，通常实际存放基类的指针（智能指针更好），这些指针所指的对象的动态类型可能是基类类型，也可能是派生类类型。

- 我们无法直接使用对象进行面向对象编程，我们必须使用指针和引用。
  