# 刷题前基础知识

---

[toc]

## 算法复杂度相关

### 时间复杂度

- **时间复杂度就是用来方便开发者估算出程序的运行时间**

  - 如何估计：计算操作单元的数量，来代表程序消耗的时间（默认CPU对每个单元消耗时间相同）

  - 假设算法的问题规模为n，则操作单元数量就是用函数f(n)来表示，随着数据规模增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度，记O(f(n))

    

### 大O

- 大O用来表示上界，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。
- 同一个算法的时间复杂度不是一成不变的，和输入的数据形式依然有关系



### 描述时间复杂度

![img](D:\MyStudyFile\Study_C_PLUS_PLUS\C-PLUS-PLUS-Road\LeetcodeC++\刷题前基础知识.assets\640)

<font color = orange>注意：我们在决定使用那些算法的时候 ，不是时间复杂越低的越好，要考虑数据规模，如果数据规模很小， 甚至可以用O(n^2)的算法比 O(n)的更合适</font>

大O其实就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个点也就是常数项系数已经不起决定性作用的点。

>  O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)(立方阶) < O(2^n) (指数阶)



### 关于O(logn)

我们平时说这个算法的时间复杂度是logn的，一定是log 以2为底n的对数么？

其实不然，也可以是以10为底n的对数，也可以是以20为底n的对数，但我们统一说 logn，也就是忽略底数的描述。

![641](D:\MyStudyFile\Study_C_PLUS_PLUS\C-PLUS-PLUS-Road\LeetcodeC++\刷题前基础知识.assets\641)

logij 是就一个常数,因此可以忽略这个常数，因此平时一般就忽略底数到底是啥。



### 简化

> O(2*n^2 + 10*n + 1000)
>
> 去掉常系数：O(n^2 + n)
>
> 去掉小一级的项，或者合并后省略加法常数O(n(n+1)) -> O(n(n)) -> O(n^2)
>
> 另一种思路，当n很大的时候O(2*n^2 + 10 * n + 1000) < O(3*n^2)，因此省略掉常系数。



### 参考

[究竟什么是时间复杂度，怎么求时间复杂度，看这一篇就够了](https://mp.weixin.qq.com/s/lYL9TSxLqCeFXIdjt4dcIw)



## 程序为什么会超时

- 一般现在判题系统的超时时间就是1s，其他OJ呢，例如POJ 或者ZOJ 超时时间都基本上都是1s
- 可以测试一下电脑1s内能够运行的次数





## 空间复杂度

- 空间复杂度是对一个算法在运行过程中占用内存空间大小的量度，记做S(n)=O(f(n))

- **空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。**

- 很有多因素会影响程序真正内存使用大小

  例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。

  **所以空间复杂度是预先大体评估程序内存使用的大小。**

```cpp
//空间复杂度为O(1)
//随着n变化，所需开辟的空间并没有变化
int j = 0;
for (int i = 0; i < n; i++) {
    j++;
}

//空间复杂度为O(n)
//随着n增加，开辟的空间需要增大
int* a = new int(n);
for (int i = 0; i < n; i++) {
    a[i] = i;
} 
```

**递归的时候，会出现空间复杂度为logn的情况**