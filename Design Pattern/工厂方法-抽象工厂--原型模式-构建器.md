

# “对象创建”模式

通过此模式绕开new， 避免对象创建（new）过程中所导致的紧耦合（以来具体类），从而支持对象创建的稳定，它是接口抽象之后的第一步工作



Factory Method

Abstract Factory

Prototype

Builder

---

# 工厂方法模式（Factory Method）

**动机**：软件系统中，经常面临创建对象的工作，由于需求的变化，需要创建的对象的具体类型经常变化

如何绕过new，提供一种封装的机制来避免这种创建对象工作的紧耦合？

**定义：**定义一个用于创建对象的接口，让子类决定实例化哪一个类，使得实例化延迟（目的：解耦，手段：虚函数）

```cpp
//工厂基类
class SplitterFactory {
public:
    virtual ISplitter* CreateSplliter() = 0;
    virtual ~SplitterFactory(){}
};

//具体工厂
class BinarySplitterFactory : public SplitterFactory{
    virtual ISplitter* CreateSplitter() {
        return new BinarySplitter;
    }
}
class TxtSplitterFactory : public SplitterFactory{
    virtual ISplitter* CreateSplitter() {
        return new TxtSplitter;
    }
}
//抽象基类
class ISplitter {
public:
    virtual void split() = 0;
   	virtual ~ISplitter(){}
};
//具体类
class FileSplitter : public ISplitter {
  	  
};
class BinarySplitter : public ISplitter {
  	  
};
class PictureSplitter : public ISplitter {
  	  
};



int main() {
    ISplitter* splitter = new BinarySplitter();  //虽然前边是抽象类，但是后边的new依赖了具体类
    											 //根据依赖倒置原则，怎么绕开new
    											 //怎么做呢？我们能不能写个东西，它返回对象
    //加一个工厂，工厂里面有虚函数
    SplitterFactory* factory;
    ISplitter* splitter = factory -> CreateSplliter(); //多态new
}
```

![image-20200920194857148](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200920194857148.png)

​		![image-20200920195034372](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200920195034372.png)







# 抽象工厂（Abstract Factory）

**动机：**面临一系列相互依赖的创建工作，分多个工厂，但多个工厂之间有关联，因此应该让一个工厂

**定义：**提供一个接口，创建一系列相互依赖的对象，无需指定具体类

```cpp
//数据库访问有关的基类
class IDBConnection{    
};
class IDBCommand{
};
class IDataReader{ 
};

class IDBFactory{
public:
    virtual IDBConnection* CreateDBConnection()=0;
    virtual IDBCommand* CreateDBCommand()=0;
    virtual IDataReader* CreateDataReader()=0;
};
//支持SQL Server这种数据库
class SqlConnection: public IDBConnection{    
};
class SqlCommand: public IDBCommand{    
};
class SqlDataReader: public IDataReader{    
};

class SqlDBFactory:public IDBFactory{
public:
    virtual IDBConnection* CreateDBConnection(){
        //TODO
    }
    virtual IDBCommand* CreateDBCommand(){
        //TODO
    }
    virtual IDataReader* CreateDataReader(){
        ??TODO
    }
 
};

//支持Oracle这种数据库
class OracleConnection: public IDBConnection{
};
class OracleCommand: public IDBCommand{   
};
class OracleDataReader: public IDataReader{  
};



class EmployeeDAO{
    IDBFactory* dbFactory;//需要传入初始化这个工厂，来获得具体的工厂类型
    
public:
    vector<EmployeeDO> GetEmployees(){
        IDBConnection* connection =
            dbFactory->CreateDBConnection();  //工厂
        connection->ConnectionString("...");

        IDBCommand* command =
            dbFactory->CreateDBCommand();
        command->CommandText("...");
        command->SetConnection(connection); //关联性

        IDBDataReader* reader = command->ExecuteReader(); //关联性
        while (reader->Read()){

        }

    }
};

```



![image-20200920200747396](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200920200747396.png)

总结：

​		解决系列对象，一特定系列下的对象之间有关联

