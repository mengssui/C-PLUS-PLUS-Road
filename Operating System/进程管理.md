

# 进程管理

## CPU管理

### 1. CPU管理的直观理解

CPU工作：**取指执行**，PC自动累加，给PC设初值

​		最直观的管理方式：给PC（程序计数器）设置初值，但是存在IO设备速度很慢（毕竟是机械设备），没有电子设备快，因此CPU工作一会，取IO设备停止，因此计算机CPU的利用率比较低。因此多个程序在内存中，多道程序交替执行提高了CPU的效率。

​		一个CPU上交替的执行多个程序：**并发**

​		切换程序时候要记录返回地址，和一些寄存器等的必要信息  -> 每个程序有一个存放信息的数据结构：**PCB  进程控制块**

​		-> 运行的程序和静态的程序是不一样的------->>>>  引入了**进程** ，表示运行中的程序 

### 2. 多进程图像

​		多进程图像从启动开始到关机结束

​		![多进程](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200903094107805.png)



#### 多进程的组织

​		使用PCB记录进程信息

![多进程组织](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200903094342316.png)



#### 多进程的切换

​		进程 = 资源 + 指令执行序列

​		

##### 用户级线程![image-20200903101004981](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200903101004981.png)

​		避免了切换代价， 不需要切换映射表，只切换指令执行序列。

 

###### Yield -> 完成切换

​		每个线程应该拥有自己的栈，线程栈

​		Yield切换时候要切换栈      TCB

​		压栈，弹栈

###### Create-> 创造出第一次切换时应该的样子

​		申请内存存放TCB，存放栈，函数入栈，关联TCB与栈

​	

![用户级线程](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200903105450707.png)

![核心级线程](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200903105633230.png)

##### 核心级线程

​		从用户级线程的**一个栈**到达一套栈，**一个用户栈，一个内核栈**

​		![image-20200903111718367](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200903111718367.png)

> ​		内核级线程switch_to 的五段论	
>
> 1. 中断入口进入切换  call 进入了内核态	
> 2. 中断处理，启动读磁盘或者是时钟中断  schedule
> 3. 找到next 下一个线程
> 4. 内核栈切换  switch_to
> 5. 中断出口 iret



 	5. ![image-20200903150846088](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200903150846088.png)

##### 内核级线程的代码实现

```c
fork() //中断是系统调用，会引起中断

```

##### 操作系统这棵树

### L13 操作系统这颗树

> CPU取指执行
> 更好的运行，则使用线程的切换
> 线程切换就要使用栈，但是使用一个栈不行，因此各个进程使用自己的栈
> 用户线程一个阻塞，别的也不能执行了，因此使用内核态的栈，变成了一套栈
> 创建fork()就是一个进程，unix系统会完全复制父进程。



### L14 多进程CPU调度

**折中是关键**

- **指标**：综合折中一下三者
    - 周转时间
    - 响应时间
    - 内耗时间
    - 吞吐量

    我们可以进一步定义一个量叫做带权周转时间，它是一个任务周转时间与实际运行时间的比值。由于排队时间不为 0，带权周转时间永远大于 1。一个系统中所有任务的平均带权周转时间越接近 1，这个系统的效率就越高。

     IO密集型和计算密集型

- **调度算法**
  
    - FCFS 先来先服务
    - SJF 短作业优先      周转时间短
    - RR 时间片轮转调度    响应时间短
    - 优先级调度
    - 多级反馈队列调度算法

###  L15 一个实际的schedule()函数

- counter既表示**优先级**也表示**时间片**
- counter = p + p/2 + p/4 + p/8 ...... < 2p
- 最长的时间片为2p

### L16 进程同步与信号量

> 进程合作，共同完成一个任务
>
> ![image-20200906182827923](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200906182827923.png)
>
> 等待信号，发送信号

##### 生产者-消费者

![image-20200906183202773](C:\Users\MengSansui\AppData\Roaming\Typora\typora-user-images\image-20200906183202773.png)

> 让进程走走停停按照一定的顺序合理运行

多个生产者，如果仅仅用发信号就不行了，所以要使用信号量，要记录有多少个进程在等待。

##### 信号量

	- 信号用来sleep或者waitup，  量用来记录
	- P操作和 V操作要是原语，具有原子性，原子操作

P 消费资源，申请

V 生产资源，释放

```c
struct semaphore{
    int value; // 记录资源的个数,表示某种资源
    //因此对于生产者，资源是空闲缓冲区个数，而对于消费者是缓冲区非空的个数
    PCB *queue; //记录等待在该信号量上的进程
};

P(semaphore s); // 消费资源
V(semaphore s); // 产生资源

P(semphore s){
    s.value--;
    if(s.value < 0)	
        sleep(s.queue); //进入阻塞队列
} 

V(semaphore s) {
    s.value++;
    if(s.value <= 0) {
        wakeup(s.queue);//从阻塞队列出来一个就绪
    }
}
```

通过信号量能够实现进程的同步和互斥

- 同步： 信号量初值为 0   先操作的进程要在执行后执行V操作；后操作的进程要在执行之前先执行P操作

- 互斥： 信号量初值为 1   执行的部分 前P 后V

    实现互斥的P操作要在实现同步的P操作之后

### L17 信号量临界区保护

**使用临界区保护信号量，使用信号量实现进程同步互斥**

- 临界区，一次只允许一个进程进入的代码段
- 修改信号量的代码一定是临界区，在进入该区域和退出该区域要进行处理（进入区和退出区）
- 互斥进入（基本），有空让进，有限等待
    - 软件法
        - 轮换法：turn公用一个turn，用完改turn   ，，有问题
        - 标记法：各自有个flag，自己置自己的标记，然后查看对方的标记，，有问题
        - Peterson算法，结合轮换和标记，很好，多个进程使用面包店算法
    - 硬件法
        - 关闭调度的中断，进入临界区关闭，出临界区开启；  **多核CPU不好用**
        - 硬件原子指令

### L18 信号量的代码实现

while循环唤醒所有进程，然后根据优先级调度

比较难哦

### L19 死锁处理

多个进程互相等待对方持有的资源而造成谁都无法执行的情况称为死锁

死锁四个必要条件：
    1.  资源互斥使用
    2. 不可抢占
 	3. 请求和保持
 	4. 循环等待

死锁处理方法：

 1. 死锁预防： 破坏死锁出现的条件

 2. 死锁避免： 检测资源请求，如果会造成死锁就拒绝

    ​	银行家算法

 3. 死锁检测 + 恢复： 检测到死锁出现，让一些进程让出进程

    ​	死锁定理

 4. 死锁忽略： 不管 （个人PC一般采用这种方式）

# 附加

## 进程通信

为了能够读取这个数据，我们只有把它存储在一个两个进程都能读取、且不会随着进程的终止而被回收的存储位置，这个位置就是**外存。**

通信方式：

​		1. 文件是对外存中的数据的抽象，我们可以利用文件进行  **进程间通信 IPC**

​		进程 A 终止前将输出值写入这个文件，然后进程 B 再将这个文件的内容作为输入值读取进来，开始运行。这是进程间通信的一种常见方法；实际上，一段内存的共享也是通过将一个共享的文件同时映射到两个进程的地址空间实现的。

  2. 信号

     类似于异常和中断，异步的。进程在接到信号后在内核态通过对应的信号处理函数来处理该信号。





### 匿名管道

pipe

我们想要一个像文件一样可以被共享的信息中转站，只用于这次通信，通信之后就自动被移除，这就是 **匿名管道（pipe）**。

匿名管道两端的进程必须具有共同祖先



### 命名管道

mkfifo

可以被不同进程使用

它不同于一般文件的一点在于**读取数据的进程和写入数据的进程必须同时出现**

### 信号

信号处理方式是在进程范围内有效的

如果一个进程用`fork()`产生一个子进程，那么在父进程中被忽略的信号在子进程中**仍然会被忽略**，但其它未被忽略的信号的处理模式都会恢复到`SIG_DFL`。

### 消息队列

​	进程间通信

​    读取消息和写入消息的两个进程不需要同时出现

​	mq

### mmap()映射

​	将外存中的文件映射到一段内存中使多个进程在其地址空间中共享一段内存





